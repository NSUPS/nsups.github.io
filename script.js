async function getSolveCounts(t){const e=await t.json(),n=e.submissions,o=e.participants,a={};for(let t in o)a[t]=o[t][0];const c={};for(let t in n){const e=n[t][1],o=a[n[t][0]],r=n[t][2];c.hasOwnProperty(o)||(c[o]=new Set),1==r&&c[o].add(e)}return c}const table=document.querySelector("table");function getColor(t){return"rgb("+((t=Math.min(100,Math.max(0,t)))<50?255:Math.round(255-5.1*(t-50)))+","+(t>50?255:Math.round(5.1*t))+",0)"}function getColorMatte(t){return"rgba("+((t=Math.min(100,Math.max(0,t)))<50?255:Math.round(255-5.1*(t-50)))+","+(t>50?255:Math.round(5.1*t))+",0, 0.3)"}function fit(t){let e=0;for(i in contests)e+=contests[i][1];const n=document.createElement("thead"),o=document.createElement("tr"),a=document.createElement("th");a.textContent="Rank",o.appendChild(a);const r=document.createElement("th");r.textContent="Name";const l=document.createElement("th");l.textContent=`Solved (${e})`,o.appendChild(r),o.appendChild(l);for(let t in contests){const e=document.createElement("th");e.textContent=`${contests[t][0]} (${contests[t][1]})`,o.appendChild(e)}n.appendChild(o),table.appendChild(n);const s=document.createElement("tbody");let d=1;for(let n in t){const o=t[n][0],a=document.createElement("tr"),r=document.createElement("td");r.textContent=""+d++,a.appendChild(r);const l=Math.floor(100*t[n][1].total/e),i=document.createElement("td");i.textContent=`${participants_names[o]}`,a.appendChild(i);const p=document.createElement("td");p.textContent=`${t[n][1].total} (${l}%)`,p.style.backgroundColor=getColor(l),a.appendChild(p);const h=t[n][1];for(c in contests){let t=0;const e=document.createElement("td");h.hasOwnProperty(c)?(e.textContent=`${h[c]}`,t=h[c]):e.textContent="x",e.style.backgroundColor=getColorMatte(100*t/contests[c][1]),a.appendChild(e)}s.appendChild(a)}table.appendChild(s)}async function run_it(){const t={};for(let e in participants_names)t[e]={};for(let e in contests){const n=await fetch(`https://vjudge.net/contest/rank/single/${e}`),o=await getSolveCounts(n);for(let n in o)participants_names.hasOwnProperty(n)&&(t[n][e]=o[n].size)}for(handle in t){let e=0;for(i in t[handle])e+=t[handle][i];t[handle].total=e}const e=Object.entries(t);e.sort(((t,e)=>e[1].total-t[1].total)),fit(e)}run_it();